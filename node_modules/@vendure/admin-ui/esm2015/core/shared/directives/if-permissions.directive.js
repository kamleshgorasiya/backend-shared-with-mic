import { ChangeDetectorRef, Directive, Input, TemplateRef, ViewContainerRef, } from '@angular/core';
import { of } from 'rxjs';
import { tap } from 'rxjs/operators';
import { DataService } from '../../data/providers/data.service';
import { IfDirectiveBase } from './if-directive-base';
/**
 * @description
 * Conditionally shows/hides templates based on the current active user having the specified permission.
 * Based on the ngIf source. Also support "else" templates:
 *
 * @example
 * ```html
 * <button *vdrIfPermissions="'DeleteCatalog'; else unauthorized">Delete Product</button>
 * <ng-template #unauthorized>Not allowed!</ng-template>
 * ```
 *
 * The permission can be a single string, or an array. If an array is passed, then _all_ of the permissions
 * must match (logical AND)
 *
 * @docsCategory directives
 */
export class IfPermissionsDirective extends IfDirectiveBase {
    constructor(_viewContainer, templateRef, dataService, changeDetectorRef) {
        super(_viewContainer, templateRef, permissions => {
            if (permissions == null) {
                return of(true);
            }
            else if (!permissions) {
                return of(false);
            }
            return this.dataService.client
                .userStatus()
                .mapStream(({ userStatus }) => {
                for (const permission of permissions) {
                    if (userStatus.permissions.includes(permission)) {
                        return true;
                    }
                }
                return false;
            })
                .pipe(tap(() => this.changeDetectorRef.markForCheck()));
        });
        this.dataService = dataService;
        this.changeDetectorRef = changeDetectorRef;
        this.permissionToCheck = ['__initial_value__'];
    }
    /**
     * The permission to check to determine whether to show the template.
     */
    set vdrIfPermissions(permission) {
        this.permissionToCheck =
            (permission && (Array.isArray(permission) ? permission : [permission])) || null;
        this.updateArgs$.next([this.permissionToCheck]);
    }
    /**
     * A template to show if the current user does not have the specified permission.
     */
    set vdrIfPermissionsElse(templateRef) {
        this.setElseTemplate(templateRef);
        this.updateArgs$.next([this.permissionToCheck]);
    }
}
IfPermissionsDirective.decorators = [
    { type: Directive, args: [{
                selector: '[vdrIfPermissions]',
            },] }
];
IfPermissionsDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: TemplateRef },
    { type: DataService },
    { type: ChangeDetectorRef }
];
IfPermissionsDirective.propDecorators = {
    vdrIfPermissions: [{ type: Input }],
    vdrIfPermissionsElse: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWYtcGVybWlzc2lvbnMuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9jb3JlL3NyYy9zaGFyZWQvZGlyZWN0aXZlcy9pZi1wZXJtaXNzaW9ucy5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILGlCQUFpQixFQUNqQixTQUFTLEVBRVQsS0FBSyxFQUNMLFdBQVcsRUFDWCxnQkFBZ0IsR0FDbkIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMxQixPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFHckMsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBRWhFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUV0RDs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFJSCxNQUFNLE9BQU8sc0JBQXVCLFNBQVEsZUFBMkM7SUFHbkYsWUFDSSxjQUFnQyxFQUNoQyxXQUE2QixFQUNyQixXQUF3QixFQUN4QixpQkFBb0M7UUFFNUMsS0FBSyxDQUFDLGNBQWMsRUFBRSxXQUFXLEVBQUUsV0FBVyxDQUFDLEVBQUU7WUFDN0MsSUFBSSxXQUFXLElBQUksSUFBSSxFQUFFO2dCQUNyQixPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNuQjtpQkFBTSxJQUFJLENBQUMsV0FBVyxFQUFFO2dCQUNyQixPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUNwQjtZQUNELE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNO2lCQUN6QixVQUFVLEVBQUU7aUJBQ1osU0FBUyxDQUFDLENBQUMsRUFBRSxVQUFVLEVBQUUsRUFBRSxFQUFFO2dCQUMxQixLQUFLLE1BQU0sVUFBVSxJQUFJLFdBQVcsRUFBRTtvQkFDbEMsSUFBSSxVQUFVLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRTt3QkFDN0MsT0FBTyxJQUFJLENBQUM7cUJBQ2Y7aUJBQ0o7Z0JBQ0QsT0FBTyxLQUFLLENBQUM7WUFDakIsQ0FBQyxDQUFDO2lCQUNELElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNoRSxDQUFDLENBQUMsQ0FBQztRQXBCSyxnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUN4QixzQkFBaUIsR0FBakIsaUJBQWlCLENBQW1CO1FBTnhDLHNCQUFpQixHQUFvQixDQUFDLG1CQUFtQixDQUFDLENBQUM7SUEwQm5FLENBQUM7SUFFRDs7T0FFRztJQUNILElBQ0ksZ0JBQWdCLENBQUMsVUFBb0M7UUFDckQsSUFBSSxDQUFDLGlCQUFpQjtZQUNsQixDQUFDLFVBQVUsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDO1FBQ3BGLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQyxDQUFDLENBQUMsQ0FBQztJQUNwRSxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUNJLG9CQUFvQixDQUFDLFdBQW9DO1FBQ3pELElBQUksQ0FBQyxlQUFlLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDbEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsaUJBQWlDLENBQUMsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7OztZQWpESixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLG9CQUFvQjthQUNqQzs7O1lBNUJHLGdCQUFnQjtZQURoQixXQUFXO1lBT04sV0FBVztZQVhoQixpQkFBaUI7OzsrQkFrRWhCLEtBQUs7bUNBVUwsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcclxuICAgIERpcmVjdGl2ZSxcclxuICAgIEVtYmVkZGVkVmlld1JlZixcclxuICAgIElucHV0LFxyXG4gICAgVGVtcGxhdGVSZWYsXHJcbiAgICBWaWV3Q29udGFpbmVyUmVmLFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBvZiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBQZXJtaXNzaW9uIH0gZnJvbSAnLi4vLi4vY29tbW9uL2dlbmVyYXRlZC10eXBlcyc7XHJcbmltcG9ydCB7IERhdGFTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vZGF0YS9wcm92aWRlcnMvZGF0YS5zZXJ2aWNlJztcclxuXHJcbmltcG9ydCB7IElmRGlyZWN0aXZlQmFzZSB9IGZyb20gJy4vaWYtZGlyZWN0aXZlLWJhc2UnO1xyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDb25kaXRpb25hbGx5IHNob3dzL2hpZGVzIHRlbXBsYXRlcyBiYXNlZCBvbiB0aGUgY3VycmVudCBhY3RpdmUgdXNlciBoYXZpbmcgdGhlIHNwZWNpZmllZCBwZXJtaXNzaW9uLlxyXG4gKiBCYXNlZCBvbiB0aGUgbmdJZiBzb3VyY2UuIEFsc28gc3VwcG9ydCBcImVsc2VcIiB0ZW1wbGF0ZXM6XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGh0bWxcclxuICogPGJ1dHRvbiAqdmRySWZQZXJtaXNzaW9ucz1cIidEZWxldGVDYXRhbG9nJzsgZWxzZSB1bmF1dGhvcml6ZWRcIj5EZWxldGUgUHJvZHVjdDwvYnV0dG9uPlxyXG4gKiA8bmctdGVtcGxhdGUgI3VuYXV0aG9yaXplZD5Ob3QgYWxsb3dlZCE8L25nLXRlbXBsYXRlPlxyXG4gKiBgYGBcclxuICpcclxuICogVGhlIHBlcm1pc3Npb24gY2FuIGJlIGEgc2luZ2xlIHN0cmluZywgb3IgYW4gYXJyYXkuIElmIGFuIGFycmF5IGlzIHBhc3NlZCwgdGhlbiBfYWxsXyBvZiB0aGUgcGVybWlzc2lvbnNcclxuICogbXVzdCBtYXRjaCAobG9naWNhbCBBTkQpXHJcbiAqXHJcbiAqIEBkb2NzQ2F0ZWdvcnkgZGlyZWN0aXZlc1xyXG4gKi9cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ1t2ZHJJZlBlcm1pc3Npb25zXScsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBJZlBlcm1pc3Npb25zRGlyZWN0aXZlIGV4dGVuZHMgSWZEaXJlY3RpdmVCYXNlPEFycmF5PFBlcm1pc3Npb25bXSB8IG51bGw+PiB7XHJcbiAgICBwcml2YXRlIHBlcm1pc3Npb25Ub0NoZWNrOiBzdHJpbmdbXSB8IG51bGwgPSBbJ19faW5pdGlhbF92YWx1ZV9fJ107XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgX3ZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsXHJcbiAgICAgICAgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4sXHJcbiAgICAgICAgcHJpdmF0ZSBkYXRhU2VydmljZTogRGF0YVNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgICApIHtcclxuICAgICAgICBzdXBlcihfdmlld0NvbnRhaW5lciwgdGVtcGxhdGVSZWYsIHBlcm1pc3Npb25zID0+IHtcclxuICAgICAgICAgICAgaWYgKHBlcm1pc3Npb25zID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvZih0cnVlKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghcGVybWlzc2lvbnMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvZihmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNlcnZpY2UuY2xpZW50XHJcbiAgICAgICAgICAgICAgICAudXNlclN0YXR1cygpXHJcbiAgICAgICAgICAgICAgICAubWFwU3RyZWFtKCh7IHVzZXJTdGF0dXMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGVybWlzc2lvbiBvZiBwZXJtaXNzaW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlclN0YXR1cy5wZXJtaXNzaW9ucy5pbmNsdWRlcyhwZXJtaXNzaW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5waXBlKHRhcCgoKSA9PiB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcGVybWlzc2lvbiB0byBjaGVjayB0byBkZXRlcm1pbmUgd2hldGhlciB0byBzaG93IHRoZSB0ZW1wbGF0ZS5cclxuICAgICAqL1xyXG4gICAgQElucHV0KClcclxuICAgIHNldCB2ZHJJZlBlcm1pc3Npb25zKHBlcm1pc3Npb246IHN0cmluZyB8IHN0cmluZ1tdIHwgbnVsbCkge1xyXG4gICAgICAgIHRoaXMucGVybWlzc2lvblRvQ2hlY2sgPVxyXG4gICAgICAgICAgICAocGVybWlzc2lvbiAmJiAoQXJyYXkuaXNBcnJheShwZXJtaXNzaW9uKSA/IHBlcm1pc3Npb24gOiBbcGVybWlzc2lvbl0pKSB8fCBudWxsO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQXJncyQubmV4dChbdGhpcy5wZXJtaXNzaW9uVG9DaGVjayBhcyBQZXJtaXNzaW9uW11dKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgdGVtcGxhdGUgdG8gc2hvdyBpZiB0aGUgY3VycmVudCB1c2VyIGRvZXMgbm90IGhhdmUgdGhlIHNwZWNpZmllZCBwZXJtaXNzaW9uLlxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgc2V0IHZkcklmUGVybWlzc2lvbnNFbHNlKHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+IHwgbnVsbCkge1xyXG4gICAgICAgIHRoaXMuc2V0RWxzZVRlbXBsYXRlKHRlbXBsYXRlUmVmKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUFyZ3MkLm5leHQoW3RoaXMucGVybWlzc2lvblRvQ2hlY2sgYXMgUGVybWlzc2lvbltdXSk7XHJcbiAgICB9XHJcbn1cclxuIl19